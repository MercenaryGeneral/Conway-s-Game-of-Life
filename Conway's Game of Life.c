#include <stdio.h>
#include <stdlib.h> //Для команды system, чтобы очищать экран между поколениями.

#define W 20 //Задаем ширину поля
#define H 20 //Задаем высоту поля

//Функция, получающая следующее поколение.
void next_gen(int prev[W][H]); //На вход поступает предыдущее поколение.
//Функция ввода первого поколения
void input_first_gen(int gen[W][H]);
//Вывод поколения на экран
void print_gen(int gen[W][H]);

int main ()
{
  int gen[W][H];
  int i, j;

  //Вводим первое поколение
  input_first_gen(gen);

  //Выводим первое поколение
  printf("Первое поколение:\n");
  print_gen(gen);

  //Начало игры
  while(1) {
    //Получаем следующее поколение из предыдущего
    next_gen(gen);

    //Выводим текущее поколение
    print_gen(gen);
  }
}

//Функция, получающая следующее поколение.
void next_gen(int prev[W][H]) //На вход поступает предыдущее поколение.
{
  int next[W][H]; //Массив следующего поколения
  int i,j,cell;
  for (i=1;i<=W-2;i++) {
    for (j=1;j<=H-2;j++) {
	    cell = prev[i-1][j-1] + prev[i-1][j] + prev[i-1][j+1]
	         + prev[i]  [j-1] + prev[i]  [j+1] + prev[i+1][j-1]
	         + prev[i+1][j] + prev[i+1][j+1]; //Определяем количество соседей у клетки с координатами (i,j) в предыдущем поколении
	    if (prev[i][j] == 1) { //Если клетка в прошлом поколении жива...
	      if ((cell == 3) || (cell == 2)) { //... и если у клетки 2 или 3 соседа,..
		 	    next[i][j] = 1;  //... то в следующем поколении клетка выживает.
		    } else {
		      next[i][j] = 0;  //Иначе в следующем поколении клетка умирает.
		    }
	    } else { //Если в месте (i,j) не существовало в предыдущем поколении...
	      if (cell == 3) { //... и если соседей трое,..
	   		  next [i][j] = 1;//то клетка рождается.
		    } else next[i][j] = 0; //Иначе клетка не рождается.
	    }
	    cell=0; //обнуляем счетчик соседей клетки.
	  }
  }

  for (i=1;i<=W-2;i++) { //В массив предыдущего поколения записываем массив следующего поколения.
    for (j=1;j<=H-2;j++) {
	    prev[i][j]=next[i][j];
	  }
  }
}

//Функция ввода первого поколения
void input_first_gen(int gen[W][H])
{
  int i,j;
  for (i=1;i<=W-2;i++) {
    for (j=1;j<=H-2;j++) {
      gen [i][j] = 0; //Обнуляем все поколение
    }
  }
  /*Вводим живые клетки первого поколения. Можно вводить свои координаты на ваше усмотрение*/
  gen[15][4]  = 1;
  gen[15][5]  = 1;
  gen[15][6]  = 1;
  gen[16][5]  = 1;
  gen[17][5]  = 1;
  gen[17][6]  = 1;
  gen[17][7]  = 1;
  gen[18][9]  = 1;
  gen[18][10] = 1;
  gen[8][1]  = 1;
  gen[5][2]  = 1;
  gen[5][3]  = 1;
  gen[5][1]  = 1;
  gen[6][1]  = 1;
  gen[7][3]  = 1;
  gen[7][2]  = 1;
  gen[7][1]  = 1;
  gen[8][9]  = 1;
  gen[8][0] = 1;
  gen[8][8]  = 1;
}

//Вывод поколения на экран
void print_gen(int gen[W][H])
{
  int i,j;

  system("cls"); //Необязательная команда для очистки экрана
  for(i=1;i<=W-2;i++) printf("_"); //Табличка для поколения
  printf("\n");

  for (i=1;i<=W-2;i++) {
	  for (j=1;j<=H-2;j++) {
	    if(gen[i][j]==1) {
		    printf ("X");
		  } else {
		    printf(" ");
      }
	  }
	  printf("|\n");
  }

  for(i=1;i<=W-2;i++)
    printf("_");
  printf("|\n");

  printf("To output the next generation, press Enter\n");
  getchar(); //Ждем подтверждения ввода с помощью клавиши Enter. Таким образом реализована пауза в выводе между поколениями.
  printf("\n");
}
